# OVH CDS Custom Actions
# .cds/actions/terraform-eks-deploy.yml

name: terraform-eks-deploy
description: Custom action to deploy EKS infrastructure with Terraform
author: DevOps Team
version: "1.0.0"

# Action parameters
parameters:
  - name: terraform_action
    description: "Terraform action to perform (plan, apply, destroy)"
    type: choice
    default: "plan"
    values: ["plan", "apply", "destroy"]
  - name: terraform_version
    description: "Terraform version to use"
    type: string
    default: "1.5.0"
  - name: auto_approve
    description: "Auto approve Terraform actions"
    type: boolean
    default: false
  - name: workspace
    description: "Terraform workspace"
    type: string
    default: "default"

# Action requirements
requirements:
  - model: linux
    os: ubuntu
    memory: 2048

# Action steps
steps:
  - name: setup-terraform
    script: |
      #!/bin/bash
      set -e
      
      # Install Terraform
      TERRAFORM_VERSION="{{.terraform_version}}"
      wget -O terraform.zip "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
      unzip terraform.zip
      sudo mv terraform /usr/local/bin/
      terraform --version
      
  - name: terraform-init
    script: |
      #!/bin/bash
      set -e
      
      # Initialize Terraform
      terraform init
      
      # Select or create workspace
      terraform workspace select "{{.workspace}}" || terraform workspace new "{{.workspace}}"
      
  - name: terraform-execute
    script: |
      #!/bin/bash
      set -e
      
      ACTION="{{.terraform_action}}"
      AUTO_APPROVE="{{.auto_approve}}"
      
      case $ACTION in
        "plan")
          terraform plan -out=tfplan
          terraform show -json tfplan > tfplan.json
          ;;
        "apply")
          if [ "$AUTO_APPROVE" = "true" ]; then
            terraform apply -auto-approve tfplan
          else
            terraform apply tfplan
          fi
          ;;
        "destroy")
          if [ "$AUTO_APPROVE" = "true" ]; then
            terraform destroy -auto-approve
          else
            terraform destroy
          fi
          ;;
        *)
          echo "Invalid action: $ACTION"
          exit 1
          ;;
      esac

---
# .cds/actions/kubectl-deploy.yml

name: kubectl-deploy
description: Custom action to deploy applications to Kubernetes
author: DevOps Team
version: "1.0.0"

parameters:
  - name: kubeconfig_path
    description: "Path to kubeconfig file"
    type: string
    default: "~/.kube/config"
  - name: namespace
    description: "Kubernetes namespace"
    type: string
    default: "default"
  - name: deployment_file
    description: "Kubernetes deployment file"
    type: string
    default: "deployment.yml"
  - name: wait_timeout
    description: "Timeout for waiting deployments (seconds)"
    type: string
    default: "300"
  - name: image_tag
    description: "Container image tag to use"
    type: string
    default: "latest"

requirements:
  - model: linux
    os: ubuntu
    memory: 1024

steps:
  - name: setup-kubectl
    script: |
      #!/bin/bash
      set -e
      
      # Install kubectl
      curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
      sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
      kubectl version --client
      
  - name: configure-kubectl
    script: |
      #!/bin/bash
      set -e
      
      # Setup kubeconfig
      export KUBECONFIG="{{.kubeconfig_path}}"
      kubectl cluster-info
      
  - name: deploy-application
    script: |
      #!/bin/bash
      set -e
      
      NAMESPACE="{{.namespace}}"
      DEPLOYMENT_FILE="{{.deployment_file}}"
      IMAGE_TAG="{{.image_tag}}"
      WAIT_TIMEOUT="{{.wait_timeout}}"
      
      # Create namespace if it doesn't exist
      kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      # Update image tags if specified
      if [ "$IMAGE_TAG" != "latest" ]; then
        sed -i "s/:latest/:$IMAGE_TAG/g" $DEPLOYMENT_FILE
        sed -i "s/:v[0-9]\+\.[0-9]\+\.[0-9]\+/:$IMAGE_TAG/g" $DEPLOYMENT_FILE
      fi
      
      # Apply deployment
      kubectl apply -f $DEPLOYMENT_FILE -n $NAMESPACE
      
      # Wait for deployments to be ready
      deployments=$(kubectl get deployments -n $NAMESPACE -o name)
      for deployment in $deployments; do
        echo "Waiting for $deployment to be ready..."
        kubectl wait --for=condition=available --timeout=${WAIT_TIMEOUT}s $deployment -n $NAMESPACE
      done
      
      # Show status
      kubectl get pods -n $NAMESPACE
      kubectl get services -n $NAMESPACE

---
# .cds/actions/security-scan.yml

name: security-scan
description: Custom action to perform security scans
author: Security Team
version: "1.0.0"

parameters:
  - name: scan_type
    description: "Type of security scan"
    type: choice
    default: "all"
    values: ["all", "terraform", "container", "kubernetes"]
  - name: severity_threshold
    description: "Minimum severity to report"
    type: choice
    default: "MEDIUM"
    values: ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
  - name: fail_on_critical
    description: "Fail pipeline on critical vulnerabilities"
    type: boolean
    default: true

requirements:
  - model: linux
    os: ubuntu
    memory: 2048

steps:
  - name: install-security-tools
    script: |
      #!/bin/bash
      set -e
      
      # Install Trivy
      sudo apt-get update
      sudo apt-get install wget apt-transport-https gnupg lsb-release
      wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
      echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
      sudo apt-get update
      sudo apt-get install trivy
      
      # Install Checkov
      pip3 install checkov
      
      # Install Hadolint for Dockerfile scanning
      wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
      chmod +x hadolint
      sudo mv hadolint /usr/local/bin/
      
  - name: terraform-security-scan
    script: |
      #!/bin/bash
      set -e
      
      SCAN_TYPE="{{.scan_type}}"
      SEVERITY="{{.severity_threshold}}"
      
      if [ "$SCAN_TYPE" = "all" ] || [ "$SCAN_TYPE" = "terraform" ]; then
        echo "Running Terraform security scan..."
        
        # Scan Terraform files with Checkov
        checkov -d . --framework terraform --output cli --output json --output-file checkov-terraform.json
        
        # Scan Terraform files with Trivy
        trivy config --format json --output trivy-terraform.json .
        trivy config --severity $SEVERITY .
      fi
      
  - name: container-security-scan
    script: |
      #!/bin/bash
      set -e
      
      SCAN_TYPE="{{.scan_type}}"
      SEVERITY="{{.severity_threshold}}"
      FAIL_ON_CRITICAL="{{.fail_on_critical}}"
      
      if [ "$SCAN_TYPE" = "all" ] || [ "$SCAN_TYPE" = "container" ]; then
        echo "Running container security scan..."
        
        # Scan Dockerfiles
        find . -name "Dockerfile*" -exec hadolint {} \;
        
        # Scan filesystem for vulnerabilities
        trivy fs --format json --output trivy-fs.json .
        
        if [ "$FAIL_ON_CRITICAL" = "true" ]; then
          trivy fs --exit-code 1 --severity CRITICAL .
        else
          trivy fs --severity $SEVERITY .
        fi
      fi
      
  - name: kubernetes-security-scan
    script: |
      #!/bin/bash
      set -e
      
      SCAN_TYPE="{{.scan_type}}"
      
      if [ "$SCAN_TYPE" = "all" ] || [ "$SCAN_TYPE" = "kubernetes" ]; then
        echo "Running Kubernetes security scan..."
        
        # Scan Kubernetes manifests
        trivy config --format json --output trivy-k8s.json .
        trivy config deployment.yml
        
        # Scan with Checkov for Kubernetes
        checkov -f deployment.yml --framework kubernetes --output json --output-file checkov-k8s.json
      fi

---
# .cds/actions/monitoring-setup.yml

name: monitoring-setup
description: Custom action to setup monitoring stack
author: Platform Team
version: "1.0.0"

parameters:
  - name: monitoring_type
    description: "Type of monitoring to setup"
    type: choice
    default: "all"
    values: ["all", "prometheus", "grafana", "alertmanager"]
  - name: namespace
    description: "Monitoring namespace"
    type: string
    default: "monitoring"
  - name: storage_size
    description: "Storage size for monitoring components"
    type: string
    default: "10Gi"
  - name: retention_period
    description: "Data retention period"
    type: string
    default: "15d"

requirements:
  - model: linux
    os: ubuntu
    memory: 2048

steps:
  - name: setup-helm
    script: |
      #!/bin/bash
      set -e
      
      # Install Helm
      curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
      helm version
      
  - name: add-helm-repositories
    script: |
      #!/bin/bash
      set -e
      
      # Add monitoring Helm repositories
      helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
      helm repo add grafana https://grafana.github.io/helm-charts
      helm repo update
      
  - name: install-monitoring
    script: |
      #!/bin/bash
      set -e
      
      MONITORING_TYPE="{{.monitoring_type}}"
      NAMESPACE="{{.namespace}}"
      STORAGE_SIZE="{{.storage_size}}"
      RETENTION="{{.retention_period}}"
      
      # Create namespace
      kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      if [ "$MONITORING_TYPE" = "all" ] || [ "$MONITORING_TYPE" = "prometheus" ]; then
        echo "Installing Prometheus..."
        helm upgrade --install prometheus prometheus-community/prometheus \
          --namespace $NAMESPACE \
          --set server.persistentVolume.size=$STORAGE_SIZE \
          --set server.retention=$RETENTION \
          --wait
      fi
      
      if [ "$MONITORING_TYPE" = "all" ] || [ "$MONITORING_TYPE" = "grafana" ]; then
        echo "Installing Grafana..."
        helm upgrade --install grafana grafana/grafana \
          --namespace $NAMESPACE \
          --set persistence.enabled=true \
          --set persistence.size=$STORAGE_SIZE \
          --set adminPassword=$(openssl rand -base64 12) \
          --wait
      fi
      
      # Show access information
      echo "Monitoring stack installed successfully!"
      kubectl get services -n $NAMESPACE

---
# .cds/actions/backup-restore.yml

name: backup-restore
description: Custom action for backup and restore operations
author: Platform Team
version: "1.0.0"

parameters:
  - name: operation
    description: "Backup or restore operation"
    type: choice
    default: "backup"
    values: ["backup", "restore", "list", "test"]
  - name: backup_name
    description: "Name of the backup"
    type: string
    default: ""
  - name: namespace
    description: "Namespace to backup/restore"
    type: string
    default: "default"
  - name: retention
    description: "Backup retention period"
    type: string
    default: "720h"

requirements:
  - model: linux
    os: ubuntu
    memory: 1024

steps:
  - name: install-velero
    script: |
      #!/bin/bash
      set -e
      
      # Download and install Velero CLI
      VELERO_VERSION="v1.11.1"
      wget https://github.com/vmware-tanzu/velero/releases/download/$VELERO_VERSION/velero-$VELERO_VERSION-linux-amd64.tar.gz
      tar -xzf velero-$VELERO_VERSION-linux-amd64.tar.gz
      sudo mv velero-$VELERO_VERSION-linux-amd64/velero /usr/local/bin/
      velero version --client-only
      
  - name: execute-operation
    script: |
      #!/bin/bash
      set -e
      
      OPERATION="{{.operation}}"
      BACKUP_NAME="{{.backup_name}}"
      NAMESPACE="{{.namespace}}"
      RETENTION="{{.retention}}"
      
      case $OPERATION in
        "backup")
          if [ -z "$BACKUP_NAME" ]; then
            BACKUP_NAME="backup-$(date +%Y%m%d-%H%M%S)"
          fi
          echo "Creating backup: $BACKUP_NAME"
          velero backup create $BACKUP_NAME --include-namespaces $NAMESPACE --ttl $RETENTION
          velero backup wait $BACKUP_NAME --timeout=30m
          ;;
        "restore")
          if [ -z "$BACKUP_NAME" ]; then
            echo "Backup name is required for restore operation"
            exit 1
          fi
          echo "Restoring from backup: $BACKUP_NAME"
          RESTORE_NAME="restore-$(date +%Y%m%d-%H%M%S)"
          velero restore create $RESTORE_NAME --from-backup $BACKUP_NAME
          velero restore wait $RESTORE_NAME --timeout=30m
          ;;
        "list")
          echo "Available backups:"
          velero backup get
          ;;
        "test")
          echo "Testing backup and restore functionality..."
          # Create test resources, backup, delete, restore, verify
          kubectl create namespace backup-test || true
          kubectl create configmap test-config --from-literal=test=value -n backup-test
          
          TEST_BACKUP="test-backup-$(date +%Y%m%d-%H%M%S)"
          velero backup create $TEST_BACKUP --include-namespaces backup-test
          velero backup wait $TEST_BACKUP --timeout=10m
          
          kubectl delete namespace backup-test
          sleep 30
          
          TEST_RESTORE="test-restore-$(date +%Y%m%d-%H%M%S)"
          velero restore create $TEST_RESTORE --from-backup $TEST_BACKUP
          velero restore wait $TEST_RESTORE --timeout=10m
          
          if kubectl get configmap test-config -n backup-test; then
            echo "Backup and restore test PASSED!"
            kubectl delete namespace backup-test
            velero backup delete $TEST_BACKUP --confirm
          else
            echo "Backup and restore test FAILED!"
            exit 1
          fi
          ;;
        *)
          echo "Invalid operation: $OPERATION"
          exit 1
          ;;
      esac
